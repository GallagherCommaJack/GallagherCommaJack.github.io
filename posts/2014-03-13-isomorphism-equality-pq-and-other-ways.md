---
title: Isomorphism, Equality, PQ, and Other Ways of Saying the Same Thing
---

Note: this whole document is literate code generated by a workflow I'll talk a bit more about tomorrow. &nbsp;It's a short shell script that's quite useful. &nbsp;You can find the program as a gist on <a href="https://gist.github.com/GallagherCommaJack/9523634">github</a>.<br />
<br />
So we’ll first take as an axiom that math is based on axioms. So far so good? Well, an important thing to note with this is that it’s really easy for axioms to have different significance - it all comes down to what metaphor you use in your brain to describe the axiomset<br />
For example, <a href="http://blog.gallabytes.com/2014/03/miu-haskellized.html">MIU</a> seems wholly abstract, but it turned out to be isomorphic to some operations on the integers modulo 3. And that isomorphism allowed some things to be made clear about it that weren’t otherwise.<br />
In Chapter 2, Hofstadter defines some axioms that he calls the “PQ system”. These axioms are:
<br />
<ol>
<li> 
The only valid characters are -, P, and Q
</li>
<li> 
-P-Q-- is a theorem
</li>
<li> 
<span class="math">∀<em>x</em>.</span> <span class="math"><em>x</em></span>P -Q -<span class="math"><em>x</em></span> is a theorem
</li>
<li> 
<span class="math">∀<em>x</em><em>y</em><em>z</em>.</span> if <span class="math"><em>x</em></span>P <span class="math"><em>y</em></span>Q <span class="math"><em>z</em></span> is a theorem, then <span class="math"><em>x</em></span>P -<span class="math"><em>y</em></span>Q -<span class="math"><em>z</em></span> is a theorem
</li>
</ol>
First lets define our types Hyphen strings are essentially equivalent to natural numbers, so we’ll make that explicit<br />
<pre><span style="color: cyan;">
</span></pre>
<pre><span style="color: cyan;">&gt;</span> <span style="color: green;"><u>data</u></span> Nat <span style="color: red;">=</span> Zero <span style="color: red;">|</span> S Nat <span style="color: green;"><u>deriving</u></span> <span style="color: cyan;">(</span>Show<span style="color: cyan;">,</span> Read<span style="color: cyan;">)</span>
<span style="color: cyan;">&gt;</span> <span style="color: green;"><u>data</u></span> Str <span style="color: red;">=</span> PQ Nat Nat Nat <span style="color: green;"><u>deriving</u></span> <span style="color: cyan;">(</span>Show<span style="color: cyan;">,</span> Read<span style="color: cyan;">)</span>
</pre>
<pre><span style="color: cyan;">
</span></pre>
Next we’ll define a few numbers for convenience<br />
<pre><span style="color: cyan;">
</span></pre>
<pre><span style="color: cyan;">&gt;</span> <span style="color: blue;">one</span> <span style="color: red;">=</span> S Zero
<span style="color: cyan;">&gt;</span> <span style="color: blue;">two</span> <span style="color: red;">=</span> S one
</pre>
<br />
And this is all we really need Now let’s define the basic axiomset<br />
<pre><span style="color: cyan;">
</span></pre>
<pre><span style="color: cyan;">&gt;</span> <span style="color: blue;">a1</span> <span style="color: red;">=</span> PQ one one two
<span style="color: cyan;">&gt;</span> <span style="color: blue;">a2</span> <span style="color: cyan;">(</span>PQ a1 a2 s<span style="color: cyan;">)</span> <span style="color: red;">=</span> PQ <span style="color: cyan;">(</span>S a1<span style="color: cyan;">)</span> a2 <span style="color: cyan;">(</span>S s<span style="color: cyan;">)</span>
<span style="color: cyan;">&gt;</span> <span style="color: blue;">a3</span> <span style="color: cyan;">(</span>PQ a1 a2 s<span style="color: cyan;">)</span> <span style="color: red;">=</span> PQ a1 <span style="color: cyan;">(</span>S a2<span style="color: cyan;">)</span> <span style="color: cyan;">(</span>S s<span style="color: cyan;">)</span>
</pre>
<br />
Now we generate a list of all the theorems by iterating a2 starting from a1, and then mapping and iterating a3 over that list.  Isn't it wonderful what you can do with lazy evaluation?

<br />
<pre><span style="color: cyan;">
</span></pre>
<pre><span style="color: cyan;">&gt;</span> <span style="color: blue;">theorems</span> <span style="color: red;">=</span> map <span style="color: cyan;">(</span>iterate a3<span style="color: cyan;">)</span> <span style="color: cyan;">$</span> iterate a2 a1
</pre>
<br />
Now this is great if we just want the list of all axioms, but not really that useful if we want to check if something’s in there. You know, given the infinite axiom space and all. So right now checking for theoremhood is actually really computationally difficult - you have to produce all axioms and just check if something’s in there. Now, there are some strings where it’s obvious that it’s not a theorem - P-Q-PPP is malformed, like "3$&amp;*("! So, how would we go about making a deterministic test that finishes in finite time? <br />
This is your cue to try and solve the problem yourself before spoilers.<br />
So, to review:
<br />
<ul>
<li>
We’ve got an infinite list of theorems, generated by some recursive rules
</li>
<li>
Our job is to somehow figure out if any given (valid) string is going to be somewhere in that list
</li>
<li>
There are two recursive rules doing the generating, so we can’t even do a linear scan through the infinite set
</li>
<li>
And, most algorithms to do diagonal scans are annoyingly complicated for what should be a simple test
</li>
<li>
Neither of those “full scan” approaches can ever give us certainty that something is a nontheorem - just that we haven’t found it yet
</li>
</ul>
Well, the simplest way is to exploit an isomorphism between PQ and arithmetic. You can see this if you interpret <span class="math"><em>x</em></span>P <span class="math"><em>y</em></span>Q <span class="math"><em>z</em></span> as <span class="math">"\(x + y = z\)"</span>. Hofstadter tried to make it clear with the suggestive names P and Q. I tried to make the hint stronger, by defining PQ in terms of natural numbers. But, to do a good theoremhood check, we first need to actually write out the code for natural number arithmetic<br />
Just for kicks, lets actually implement the <a href="https://en.wikipedia.org/wiki/Peano_axioms">Peano Axioms</a>, or at least the ones we need.<br />
First, let’s define equality<br />
<br />
<pre><span style="color: cyan;">&gt;</span> <span style="color: green;"><u>instance</u></span> Eq Nat <span style="color: green;"><u>where</u></span>
</pre>
<pre><span style="color: green;"><u>
</u></span></pre>
First, m = n iff S(m) = S(n) (Peano Axiom 8) An equivalent to the above is that S(m) = S(n) iff m = n<br />
<br />
<pre><span style="color: cyan;">&gt;</span>     <span style="color: cyan;">(</span>S n1<span style="color: cyan;">)</span> <span style="color: cyan;">==</span> <span style="color: cyan;">(</span>S n2<span style="color: cyan;">)</span> <span style="color: red;">=</span> n1 <span style="color: cyan;">==</span> n2
</pre>
<br />
Equality is reflexive (Peano Axiom 1)<br />
<pre><span style="color: cyan;">
</span></pre>
<pre><span style="color: cyan;">&gt;</span>     Zero <span style="color: cyan;">==</span> Zero     <span style="color: red;">=</span> True
</pre>
<br />
Now that we’ve defined both our truth patterns, we can rest assured that every other case will turn out false<br />
<pre><span style="color: cyan;">
</span></pre>
<pre><span style="color: cyan;">&gt;</span>     <span style="color: green;"><u>_</u></span> <span style="color: cyan;">==</span> <span style="color: green;"><u>_</u></span>           <span style="color: red;">=</span> False
</pre>
<br />
Next we’ll define all the arithmetic required by the Num typeclass<br />
<pre><span style="color: cyan;">
</span></pre>
<pre><span style="color: cyan;">&gt;</span> <span style="color: green;"><u>instance</u></span> Num Nat <span style="color: green;"><u>where</u></span>
</pre>
<br />
Zero is the additive identity, and this definition of addition actually looks about the same as Peano Addition If we’re adding Zero, then we can just return the other number And, S(n) + a = S(n + a). The pattern match to S(n1) + S(n2) is just a way of increasing the speed at which the recursion terminates<br />
<pre><span style="color: cyan;">
</span></pre>
<pre><span style="color: cyan;">&gt;</span>   <span style="color: cyan;">(</span>S n1<span style="color: cyan;">)</span> <span style="color: cyan;">+</span> <span style="color: cyan;">(</span>S n2<span style="color: cyan;">)</span> <span style="color: red;">=</span> S <span style="color: cyan;">.</span> S <span style="color: cyan;">$</span> n1 <span style="color: cyan;">+</span> n2
<span style="color: cyan;">&gt;</span>   n <span style="color: cyan;">+</span> Zero <span style="color: red;">=</span> n
<span style="color: cyan;">&gt;</span>   Zero <span style="color: cyan;">+</span> n <span style="color: red;">=</span> n
</pre>
<br />
Next we’ve got multiplication, if only because it’s required by the typeclass. It’s just repeated addition, so this is pretty simple. The first rule is that anything multiplied by Zero is Zero. &nbsp;The second rule is that for any n1*S(n2) = n1 + n1*n2.<br />
<pre><span style="color: cyan;">
</span></pre>
<pre><span style="color: cyan;">&gt;</span>   n1 <span style="color: cyan;">*</span> <span style="color: cyan;">(</span>S n2<span style="color: cyan;">)</span> <span style="color: red;">=</span> n1 <span style="color: cyan;">+</span> n1 <span style="color: cyan;">*</span> n2
<span style="color: cyan;">&gt;</span>   Zero <span style="color: cyan;">*</span> <span style="color: green;"><u>_</u></span> <span style="color: red;">=</span> Zero
<span style="color: cyan;">&gt;</span>   <span style="color: green;"><u>_</u></span> <span style="color: cyan;">*</span> Zero <span style="color: red;">=</span> Zero
</pre>
<br />
More num class fillers<br />
<pre><span style="color: cyan;">
</span></pre>
<pre><span style="color: cyan;">&gt;</span>   negate <span style="color: red;">=</span> undefined</pre>
<pre><span style="color: cyan;">&gt;</span>   abs <span style="color: red;">=</span> id
</pre>
<pre><span style="color: cyan;">&gt;</span>   signum <span style="color: green;"><u>_</u></span> <span style="color: red;">=</span> one
<span style="color: cyan;">&gt;</span>   fromInteger <span style="color: magenta;">0</span> <span style="color: red;">=</span> Zero
<span style="color: cyan;">&gt;</span>   fromInteger n <span style="color: red;">=</span> S <span style="color: cyan;">$</span> fromInteger <span style="color: cyan;">$</span> n <span style="color: blue;"><i>-</i></span> <span style="color: magenta;">1</span>
</pre>
<br />
So now we’ve got the tools to create a function that would test axiomhood, but it’d be horribly inefficient. It’d look something like this:<br />
<code>isTheorem (PQ a1 a2 s) = a1 + a2 == s</code><br />
Now, that’s all well and good, but it first has to do the O(n) addition of <span class="math"><em>a</em>1</span> and <span class="math"><em>a</em>2</span>, then the O(n) equality of <span class="math"><em>a</em>1</span> + <span class="math"><em>a</em>2</span> and <span class="math"><em>s</em></span>. Surely we can make this into one n, instead of two? Well, the way to do so is actually really easy - we just exploit the isomorphism between addition and subtraction.<br />
First, we define our recursive rule<br />
<pre><span style="color: cyan;">
</span></pre>
<pre><span style="color: cyan;">&gt;</span>   <span style="color: cyan;">(</span>S n1<span style="color: cyan;">)</span> <span style="color: blue;"><i>-</i></span> <span style="color: cyan;">(</span>S n2<span style="color: cyan;">)</span> <span style="color: red;">=</span> n1 <span style="color: blue;"><i>-</i></span> n2
</pre>
<br />
Next, our base cases. Subtracting Zero from anything is just a null op, and we don’t have a clear definition in PQ of negative numbers - you can’t have -5 hyphens<br />
<pre><span style="color: cyan;">
</span></pre>
<pre><span style="color: cyan;">&gt;</span>   n <span style="color: blue;"><i>-</i></span> Zero <span style="color: red;">=</span> n
<span style="color: cyan;">&gt;</span>   Zero <span style="color: blue;"><i>-</i></span> <span style="color: green;"><u>_</u></span> <span style="color: red;">=</span> undefined
</pre>
<br />
So from there our work is really easy - we can just recurse down once The algorithm below will take exactly <span class="math">(<em>a</em>1 + <em>a</em>2)</span> iterations to check for theoremhood<br />
<pre><span style="color: cyan;">
</span></pre>
<pre><span style="color: cyan;">&gt;</span> <span style="color: blue;">isTheorem</span> <span style="color: cyan;">(</span>PQ a1 a2 s<span style="color: cyan;">)</span> <span style="color: red;">=</span> s <span style="color: blue;"><i>-</i></span> a1 <span style="color: blue;"><i>-</i></span> a2 <span style="color: cyan;">==</span> Zero
</pre>
<br />
And with that we’re done - we’ve defined the PQ system, written out something to list all the theorems, discovered some novel properties of it, and leveraged those to write a quick theoremhood tester. &nbsp;Not bad, eh?
